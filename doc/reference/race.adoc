[#race]
== async/race.hpp

The `race` function can be used to `co_await` one <<awaitable>>s out of a set of them.

`race` gets evaluated strictly from left to right,
i.e. the left-most awaitable that is ready will be used.
This can lead to starvation which is why <<select>> shoud be considered as a sound default.

It can be called as a variadic function with multiple <<awaitable>> or as on a range of <<awaitable>>s.

[source,cpp]
----
async::promise<void> task1();
async::promise<void> task2();

async::promise<void> do_wait()
{
  co_await async::race(task1(), task2()); // <1>
  std::vector<async::promise<void>> aws {task1(), task2()};
  co_await async::race(aws); // <2>
}
----
<1> Wait for a variadic set of <<awaitable>>s
<2> wait for a vector of <<awaitable>>s

[#interrupt_await]
=== Interrupt Wait

When arguments are passed as rvalue reference, the race will attempt to use `.interrupt_await`
on the awaitable to detach the not completed <<awaitable>>s. If supported, the <<awaitable>> must complete immediately.
If the `race` doesn't detect the immediate completion, it will send a cancellation.

This means that you can reuse race like this:

[source,cpp]
----

async::promise<void> do_wait()
{
  auto t1 = task1();
  auto t2 = task2();
  co_await async::race(t1, t2); // <1>
  co_await async::race(t1, t2); // <2>
}
----
<1> Wait for the first task to complete
<2> Wait for the other task to complete

This is supported by <<promise, promise>>, <<generator, generator>> and <<gather, gather>>.

The `race` will invoke the functions of the `awaitable` as if used in a `co_await` expression,
with two exceptions:

 1. A call to `await_ready` might not be followed by `await_suspend` when returning false.
 2. A call to `operator co_await` may not be followed by a call to any `await_*` function.