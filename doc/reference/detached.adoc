[#detached]
== async/detached.hpp

A detached is an eager coroutine that can `co_await` but not `co_return` values.
That is, it cannot be resumed and is usually not awaited.

[source,cpp]
----
async::detached delayed_print(std::chrono::milliseconds ms)
{
  asio::steady_timer tim{co_await async::this_coro::executor, ms};
  co_await tim.async_wait(async::use_op);
  printf("Hello world\n");
}

async::main co_main(int argc, char *argv[])
{
  delayed_print();
  co_return 0;
}
----

Promises are mainly used to spawn tasks easily.

[source,cpp]
----
async::detached my_task();

async::main co_main(int argc, char *argv[])
{
  my_task(); // <1>
  co_await delay(std::chrono::milliseconds(50));
  co_return 0;
}
----

=== Executor
[#detached-executor]

The executor is taken from the `thread_local` <<this_thread, get_executor>> function, unless a `asio::executor_arg` is used
in any position followed by the executor argument.

[source, cpp]
----
async::detached my_gen(asio::executor_arg_t, asio::io_context::executor_type exec_to_use);
----

=== Memory Resource
[#detached-allocator]

The memory resource is taken from the `thread_local` <<this_thread, get_default_resource>> function,
unless a `std::allocator_arg` is used in any position followed by a `polymorphic_allocator` argument.

[source, cpp]
----
async::detached my_gen(std::allocator_arg_t, pmr::polymorphic_allocator<void> alloc);
----

[#detached-outline]
=== Outline


[source,cpp]
----
include::../../include/boost/async/detached.hpp[tag=outline]
----
<1> Supports <<interrupt_await>>

[#detached-detached]
=== Promise

The thread detached has the following properties.

- <<promise_memory_resource_base>>
- <<promise_cancellation_base>>
- <<promise_throw_if_cancelled_base>>
- <<enable_awaitables>>
- <<enable_await_allocator>>
- <<enable_await_executor>>

